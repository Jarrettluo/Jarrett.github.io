[{"id":"2a565706375e8204a992e2f354c7a89e","title":"我写了一个Flask-restful的快速模板","content":"前言前几天在进行项目开发的时候，发现用Flask写一些轻量化的Web程序还是比较合适的。其实在Flask家族中，为了能够更加方便的开发Restful风格的接口，Flask-restful是一个不错的选择。虽然Flask-restful提供了比较完整的官方文档，但是距离开发上线项目还是不是很方便，因此我写了一个Flask-restful的快速模板。\n此项目采用Mysql作为持久层数据库，实现了一个资源的5个接口，满足基本的web开发需求。\n项目地址首先给出项目地址：Flask-restful-quick-start\n项目简介首先是项目的文件结构。├── flask_app\n│   ├── common\n│   │   ├── __init__.py\n│   │   └── utils.py\n│   ├── user\n│   │   ├── __init__.py\n│   │   ├── models.py\n│   │   └── views.py\n│   └── __init__.py\n├── config.py\n├── LICENSE\n├── main.py\n└── requirements.txt\n\n项目中采用了蓝图来划分功能块，方面划分项目模块，并且提升可维护性。\n目前我认为这是一个相对比较科学的文件组织方案了。\nRestful接口设计基本的接口从两个路由进行接收\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n请求方法\t\t路由\t\t\t\t请求内容\nPOST\t\t&#x2F;userList\t\t\tuserInfo\nGET\t\t\t&#x2F;userList\t\t\tNone\nGET\t\t\t&#x2F;user\t\t\t\tuserId\nPUT\t\t\t&#x2F;user\t\t\t\tuserInfo\nDELETE\t\t&#x2F;user\t\t\t\tuserId\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n做一个简单的介绍就是增加资源和查询全部资源从资源列表接口走。\n其他的带参数请求和修改、删除等从专门的资源接口走。\n这样就能避免GET请求带参数和不带参数的问题了。\n在项目中统一的处理能够提升可靠性，降低编码错误，我这里对两点进行了统一。1、Sqlalchemy的Model层对象和dict之间的转换。\ndef row2dict(row):\n    \"\"\"\n    参考文档 https://stackoverflow.com/questions/1958219/convert-sqlalchemy-row-object-to-python-dict\n    将model转换为dict\n    :param row: Sqlalchemy model\n    :return: 输出的字典\n    \"\"\"\n    out_dict = &#123;&#125;\n    for column in row.__table__.columns:\n        out_dict[column.name] = str(getattr(row, column.name))\n    return out_dict\n\n\n通过以上代码即可轻松地将model转换为dict的字典了。\n2、统一的回复内容\nclass BaseResponse:\n    def __init__(self):\n        self.result_code_success = 200\n        self.result_code_fail = 201\n\n    def success(self, msg=\"success\", data=&#123;&#125;):\n        result = &#123;\n            \"code\": self.result_code_success,\n            \"message\": msg,\n            \"data\": data\n        &#125;\n        return jsonify(result)\n\n    def fail(self, msg=\"fail\", data=&#123;&#125;):\n        result = &#123;\n            \"code\": self.result_code_fail,\n            \"message\": msg,\n            \"data\": data\n        &#125;\n        return jsonify(result)\n\n统一的回复内容包括了“成功”和“失败”两种情况，可自定义回复编码和内容。\n启动项目安装首先克隆本项目\n$ git clone git@github.com:Jarrettluo&#x2F;flask-restful-quick-start.git\n\ncd flask-restful-quick-start\n\n建议大家使用ide创建一个虚拟环境venv，避免项目使用的包与系统包不一致。\n$ pip install requirements.txt\n\n最后启动项目，开始开发\n$ python run main.py\n\n\n\n修改配置在项目中的__init__.py中设置了连接数据库的各项参数，这些都是需要来自定义设置的。\nuser = \"root\"\npassword = \"123456\"\ndatabase = \"flask_quick\" # 需要修改的内容\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = \"mysql://%s:%s@localhost:3306/%s\" % (user, password, database)\n\n在这里使用了MysqlDB，可以根据实际情况，进行修改。\n同时也强烈建议大家将这些设置信息放到config.py文件中，这样方便统一修改。\n在主程序中，防止了一个数据库初始化的方法，可以进行数据库的清空和创建。\ndef init_db():\n    # 丢掉全部表\n    db.drop_all()\n    # 创建全部表\n    db.create_all()\n\n\n\n快速开发增加模块就只需要将现有的user模块复制以后进行修改即可。\n在flask_app.__init.py中注册蓝图\nfrom flask_app.user import user_blueprint\napp.register_blueprint(user_blueprint, url_prefix=\"/user\")\n\n在flask_app.user.__init.py中增加蓝图\nuser_blueprint = Blueprint(\"user_blueprint\", __name__, url_prefix=\"/user\")\nfrom flask_app.user import views\n\nenjoy。\n结尾纯新手向的指导，更多的内容请参考Flask_restful的官方文档.\n\n\n\n\n\n\n\n\n\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"我写了一个Flask-restful的快速模板","date":"2021-11-14T06:13:45.000Z","categories_index":"","tags_index":"Mysql,Python,Flask","author_index":"JIARUI's BLOG"},{"id":"62d76556d121d2872e8a9782563ea5e2","title":"mm-wiki的packets.go:36: unexpected EOF解决","content":"背景MM-Wiki 是一个轻量级的企业知识分享与团队协同软件，可用于快速构建企业 Wiki 和团队知识分享平台。部署方便，使用简单，帮助团队构建一个信息共享、文档管理的协作环境。https://github.com/phachon/mm-wiki\n某天服务器磁盘满了以后，出现已经登录的用户会闪退回登录界面的问题。以下是debug的过程。\n环境介绍Linux 18.04\nmm-wiki 0.2.1\nmysql\n\n问题排查在mm-wiki的\nmm_wiki\n├── logs\n│    └──mm-wiki.logs\n└──nohup.out\n\n\n解决问题在网上查找该问题，发现是go-sql-driver的问题，而且有人给出了解决办法。\n在该issure下出现的回打如下，就是将最大空闲链接设置为0。\n查找网上的设置方法: SetMaxIdleConns默认情况下 sql.DB 会在链接池中最多保留 2 个空闲链接。可以通过 SetMaxIdleConns() 方法更改此方法，如下所示:\n&#x2F;&#x2F; 初始化一个新的链接池\ndb, err :&#x3D; sql.Open(&quot;postgres&quot;, &quot;postgres:&#x2F;&#x2F;user:pass@localhost&#x2F;db&quot;)\nif err !&#x3D; nil &#123;\n    log.Fatal(err)\n&#125;\n\n&#x2F;&#x2F; 将最大并发空闲链接数设置为 5.\n&#x2F;&#x2F; 小于或等于 0 表示不保留任何空闲链接.\ndb.SetMaxIdleConns(5)\n\nStack overflow 提供的解决办法也是将MaxIdleConnections修改为0就解决该问题。https://stackoverflow.com/questions/39980902/golang-mysql-error-packets-go33-unexpected-eof\n针对mm-wiki的解决方法如下。首先找到配置文件，所在路径为mm_wiki/conf/mm-wiki.conf\n$ cd &#x2F;mm_wiki&#x2F;conf&#x2F;\n$ sudo nano mm  mm-wiki.conf\n将其中的conn_max_idle修改为0。然后ctrl + x保存文件后退出。\n修改完毕以后，尝试启动项目：\n$ .&#x2F;mm-wiki --conf conf&#x2F;mm-wiki.conf\n如果启动成功可以使用nohup将项目挂载起来。\n$ nohup .&#x2F;mm-wiki --conf conf&#x2F;mm-wiki.conf &amp;\n\n总结系统设计的时候，也应该有个conf文件，避免debug的时候需要重新编译和打包，这种设计方案可以在生产环境中直接重启，让配置生效。\n参考文档\n如何配置 sql.DB 的 SetMaxOpenConns SetMaxIdleConns 和 SetConnMaxLifetime\n\n","slug":"mm-wiki的packets-go-36-unexpected-EOF解决","date":"2021-11-14T06:10:32.000Z","categories_index":"debug","tags_index":"go","author_index":"JIARUI's BLOG"},{"id":"e1808551f050f3a6ba3836556587dcae","title":"Docker应用连接TDengine数据库的解决方案","content":"1、工作环境开发工具：IDEA，安装插件docker\nTDengine Version：2.0.20.5\ntaos jdbc Version: 2.0.22\nSpringboot Version: 2.4.5\nDocker Version： 20.10.10\n\n2、Dockerfile设置### 基础镜像\nFROM openjdk:8\n\n### 作者\nMAINTAINER luojiarui &lt;luojiarui2@163.com&gt;\n\n### 系统编码\nENV LANG&#x3D;C.UTF-8 LC_ALL&#x3D;C.UTF-8\n\n### 声明挂载点，容器内此路径会对应宿主机的某个文件夹\nVOLUME &#x2F;tmp\n\n### 应用构建成功以后jar文件被复制到镜像内，名字也改为app.jar\nADD target&#x2F;service-app-1.0-SNAPSHOT.jar app.jar\n\n### 启动容器时的进程\nENTRYPOINT [&quot;java&quot;， &quot;-jar&quot;, &quot;&#x2F;app.jar&quot;]\n\n### 暴露的端口\nEXPOSE 8099\n    \n\n\n在IDEA中编写一个Dorckerfile，文件的位置和springboot项目的根目录一致。\n使用远程的Ubuntu服务器的docker进行镜像打包和部署。\n再检查一遍项目的配置文件，这里需要设置jdbc的连接配置：\n### 设置JDBC的连接地址，必须加上taos的账号密码，这里使用的是TDengine的默认密码\ntaosJdbc:\n    url: jdbc:TAOS://node1:6030//alpha_db？user=root&amp;password=taosdata\n\n### 使用Restful连接taos的配置也记录下来\nurl:\n    taos-path: http://node1:6041/rest/sql\n    table: alpha_db.can_super\n\n\n从项目的配置文件中，可以看到FQDN设置的是node1。\nnode1是TDengine机所在机器的地址，其真实ip地址为： 129.122.12.12。\n特别要注意这里的修改，否则会出现问题。\n\n3、创建容器根据镜像文件service-app:v1创建容器的命令如下。\ndocker run \n    -d ## 后台运行\n    -name service-app ## 容器命令\n    -p 8099:8099 ## 端口映射，&lt;主机端口: 容器端口&gt;\n    -v &#x2F;usr&#x2F;local&#x2F;taos&#x2F;driver&#x2F;libtaos.so.2.0.20.5:&#x2F;usr&#x2F;lib&#x2F;libtaos.so ## 指定容器里taos的数据库客户端\n    -v &#x2F;usr&#x2F;share&#x2F;zoneinfo:&#x2F;usr&#x2F;share&#x2F;zoneinfo ## 数据卷映射\n    -e TZ&#x3D;AsiaShanghai ## 时区\n    --add-host&#x3D;node1:10.30.5.55 ## 增加DNS解析\n    service-app:v1 ## 容器名\n\n\n4、容器内缺少驱动问题1: java使用JDBC建立简介，在windows系统上可以正常运行，打包放到docker容器中运行时，出现如下异常：$ Caused by: Java.lang.NoClassDefFonderError： Could not initialize calss com.taosdata.jdbc.TSDBJNIConnecter\n....\n通过查找前人的方案，通过指定taos驱动和时区，解决该问题。\nhttps://github.com/taosdata/TDengine/issues/4238 “java.lang.NoClassDefFoundError: Could not initialize class com.taosdata.jdbc.TSDBJNIConnector #4238”\n问题2：使用的基础镜像Aline不支持$ &#x2F;user&#x2F;lib&#x2F;libtaos.so: Error loading shared libary ld-linux-x86-64.so.2: No such file or directory (needed by &#x2F;usr&#x2F;lib&#x2F;libtaos.so)\n...\n在驱动已经映射的基础上，依然缺少某些文件，那么就找一下为什么缺少的原因。\n进入docker以后，查找一下。\n### 进入docker\nroot@xxxx: docker exec -it service-app sh\n\n### 查找\n&#x2F;# ldd &#x2F;usr&#x2F;lib&#x2F;libtaos.so\n    ldd(0x7fefebee2000)\n    libpthread.so.0 &#x3D;&gt; ldd(0x7fefebee2000)\n    libm.so.6 &#x3D;&gt; ldd(0x7fefebee2000)\n    librt.so.1 &#x3D;&gt; ldd(0x7fefebee2000)\n    libc.so.6 &#x3D;&gt; ldd(0x7fefebee2000)\nError loading shared libaray ld-linux-x86-64.so.2: No such file or directory (need by &#x2F;usr&#x2F;lib&#x2F;libtaos.so)\nError relocating &#x2F;usr&#x2F;lib&#x2F;libtaos.so: _pthread_register_cancel: sysbol not found\n...\n可以看出这里缺少某些东西，判断是由于我们使用了精简版的JDK，那么我们就将原来的alpine版本的JDK给更换掉。\n### 原来的基础镜像\nFROM openjdk:8-alpine\n\n### 更换为\nFROM openjdk:8\n通过更换基础镜像，虽然镜像文件从161MB增加到了320MB，但是该问题解决。\n\n5、容器无法连接TDengine无法连接TDengine： TDengine ERROR （80000015）： Unable to resolve FQDN.\nJNI CONNECTION is NULL\n解决该问题的办法即是注意JDBC连接的时候不能使用IP地址，然后在运行的容器的时候增加以下的命令。\n--add-host=node1:10.30.5.55 ## 增加DNS解析\n\n\n6、总结目前TDengine暂时没有看到官方指导案例，在使用docker连接TDengine的时候注意以上细节，一般不会有任何问题。另外还要注意设置docker的时区问题，否则在使用时间范围查询数据库时会出现时区偏差。\n特别感谢涛思数据的董工提供的技术支持。\n\n\n\n\n\n\n\n\n\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"Docker应用连接TDengine数据库的解决方案","date":"2021-11-03T11:20:11.000Z","categories_index":"后端开发","tags_index":"docker,TDengine","author_index":"JIARUI's BLOG"},{"id":"96d44811f44a8268573d11efdeedbe54","title":"Javascript 对象数组取差集和交集的方法","content":"前言对象数组常会进行取交集或者差集的操作。假设有对象数组A和对象数组B，常规方法是比较B对象数组与A对象数组的差异，进而找到其差集或者交集。但是现在面临的问题是数组A 和数组B中的对象可能不完全一样的情况，可采用以下方法解决该问题。\n对象数组的定义我们把对象数组A定义为长数组，其中包含的对象属性包括了name, age, weight 等三个属性；对象数组B定义为短数组，这里是指其元素个数小于数组A，其对象属性包括了name, age等2个属性。\nlet wideArray &#x3D; [&#123;name: &quot;luojiarui&quot;, age: 18, weight: 78&#125;, &#123;name: &quot;zhangqirui&quot;, age: 28, weight: 70&#125;];\nlet shortArray &#x3D; [&#123;name: &quot;zhangqirui&quot;, age: 28&#125;];\n如果我们进行取对象的交集，那么就首先需要将对象属性进行重新处理为一样的属性，再进行差异比较。\n最终的差集是：\nfinalArray = [&#123;name: \"luojiarui\", age: 18, weight: 78&#125;]\n最终的交集是：\nfinalArray = [&#123;name: \"zhangqirui\", age: 28, weight: 70&#125;]\n\n找出对象中的特定的属性对象中特定属性的查找可以采用遍历对象的方法，我们这里采用reduce。首先我们看官方案例中计算，数组里所有值的和。这里采用累计器和当前值不断累积，最终计算出整个数组的和。注意在reduce的第二个参数中可以给出累加器的初始值，这里代码给出的是0。\nvar sum &#x3D; [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123;\n  return accumulator + currentValue;\n&#125;, 0);\n&#x2F;&#x2F; 和为 6\n也可以写成箭头函数的形式：\nvar total &#x3D; [ 0, 1, 2, 3 ].reduce(\n  ( acc, cur ) &#x3D;&gt; acc + cur,\n  0\n);\n这里，我封装了一个函数，名叫pick。其用途是找出对象中指定的属性，且属性是必须包含。\nfunction pick(obj, arr) &#123;\n  // 参考网络上关于对象属性查找的方法，但是其没有指定必须包含该属性。\n  // return arr.reduce((iter, val) => (val in obj &amp;&amp; (iter[val] = obj[val]), iter), &#123;&#125;);\n  // 如果你打算提供一个初始值作为reduce()方法的第二个参数\n  return arr.reduce((iter, val) => &#123;\n     if(val in obj) &#123;\n        iter[val] = obj[val];\n      &#125;else &#123;\n        iter = &#123;&#125;\n      &#125;\n      return iter;\n        &#125;, &#123;&#125;);\n&#125;\n应用示例：\nvar object = &#123; name: \"ljr\", age: 23, weight: 68&#125;;\nvar newObject = pick(object, [\"name\", \"age\"]); // 从对象中取到name和age属性。\n// output: &#123; name: \"ljr\", age: 23&#125;;\n\nvar newObject1 = pick(object, [\"name\", \"price\"]); // 从对象中取到name和price 属性。\n// output : &#123;&#125;; // 由于对象中不存在price属性，因此返回值是空对象。\n\n\n\n\n\n\n\n\n\n\n关于reduce的更多介绍可以查阅mdn。\nReduce() 方法讲解： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n差集和交集的计算接下来通过遍历长数组元素，找出差集和交集。这里采用了很方便的一种比较方式，那就是使用indexOf。但是该方法主要是应用于简单类型的数组或者字符串中，不能比较对象数组。因此将对象数组转换为字符串进行比较。字符串比较的前提是，在前文中已经将对象数组进行重整，每个数组元素的属性已经是一致的。indexOf 的原理是查找被查元素的索引，如果不能查到该元素则返回-1，如果能找到则返回该元素的索引值。\n&#x2F;&#x2F; 遍历长对象数组，同时取到两个对象数组的差集，交集\nvar substractedArray &#x3D; [], intersectionArray &#x3D; []; &#x2F;&#x2F; 差集， 交集\nwideArray.forEach( value &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 等于-1 表示 不存在，大于-1 表示存在\n    if(JSON.stringify(pickedShortArray)\n    .indexOf(JSON.stringify(pick(value,focusKeys))) &#x3D;&#x3D; -1) &#123;\n        substractedArray.push(value)\n    &#125;else &#123;\n        intersectionArray.push(value)\n    &#125;\n&#125;)\n最终将查到的对象放入差集和交集数组中。\n应用默认传入参数为长对象数组，短对象数组，指定对象属性数组，差集或者交集方法。默认对象属性数组为空，默认为差集方法。对象属性数组可以通过wideArray[0].keys传入。\nlet wideArray &#x3D; [&#123;name: &quot;luojiarui&quot;, age: 18, weight: 78&#125;, &#123;name: &quot;zhangqirui&quot;, age: 28, weight: 70&#125;];\nlet shortArray &#x3D; [&#123;name: &quot;zhangqirui&quot;, age: 28&#125;];\nvar a &#x3D; arrayFilter(wideArray, shortArray, [ &quot;name&quot;, &quot;age&quot;], &quot;substract&quot;);\nconsole.log(a);\nvar b &#x3D; arrayFilter(wideArray, shortArray, shortArray[0].keys, &quot;intersect&quot;);\nconsole.log(b);\n\n附录如下是源代码，感兴趣的同学可以拷贝进行测试。\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &lt;title>Document&lt;/title>\n&lt;/head>\n&lt;body>\n    &lt;div>对象数组的交集并集&lt;/div>\n    &lt;script>\n        let wideArray = [&#123;name: \"luojiarui\", age: 18, weight: 78&#125;, &#123;name: \"zhangqirui\", age: 28, weight: 70&#125;];\n        let shortArray = [&#123;name: \"zhangqirui\", age: 28&#125;];\n        var a = arrayFilter(wideArray, shortArray, [ \"name\", \"age\"], \"substract\");\n        console.log(a);\n\n        /**\n         * @desription \n         * @param \n         * @param\n         * @author 罗佳瑞\n         * @since 2021年10月18日\n         * */\n        function arrayFilter(wideArray, shortArray, focusKeys=[], method=\"substract\")&#123;\n            if(!Array.isArray(wideArray) || !Array.isArray(shortArray) || \n            !Array.isArray(focusKeys) || focusKeys.length === 0 || method === \"\") &#123;\n                return &#123;\n                    state: false,\n                    info: \"Param is error!\",\n                    result: []\n                &#125;\n            &#125;\n            // 判断传入的对象数组长度，如果两者长度不符合要求，那么进行交换\n            if(wideArray.length &lt; shortArray.length ) &#123;\n                var tempArray = wideArray;\n                wideArray = shortArray;\n                shortArray = tempArray;\n            &#125;\n            // 定义返回参数\n            var finalArray = &#123;\n                state: true,\n                info: method + \"ing array successfully!\",\n                result: []\n            &#125;;\n            // 对短数组进行遍历挑选，找到符合要求的对象属性\n            var pickedShortArray = [];\n            shortArray.forEach(element => &#123;\n                var pickedObject = pick(element, focusKeys)\n                if(pickedObject != &#123;&#125;) pickedShortArray.push(pickedObject);\n            &#125;)\n            if(pickedShortArray.length == 0 ) return finalArray;\n\n            // 遍历长对象数组，同时取到两个对象数组的差集，交集\n            var substractedArray = [], intersectionArray = []; // 差集， 交集\n            wideArray.forEach( value => &#123;\n                // 等于-1 表示 不存在，大于-1 表示存在\n                if(JSON.stringify(pickedShortArray)\n                .indexOf(JSON.stringify(pick(value,focusKeys))) == -1) &#123;\n                    substractedArray.push(value)\n                &#125;else &#123;\n                    intersectionArray.push(value)\n                &#125;\n            &#125;)\n\n            switch (method) &#123;\n                case \"substract\": \n                    finalArray.result = substractedArray;\n                    break;\n                case \"intersect\":\n                    finalArray.result = intersectionArray;\n                    break\n                default:\n                    finalArray.state = false;\n                    finalArray.info = \"method is error\";\n            &#125;\n            return finalArray;\n        &#125;\n        function pick(obj, arr) &#123;\n            // return arr.reduce((iter, val) => (val in obj &amp;&amp; (iter[val] = obj[val]), iter), &#123;&#125;);\n            // 如果你打算提供一个初始值作为reduce()方法的第二个参数\n            return arr.reduce((iter, val) => &#123;\n                if(val in obj) &#123;\n                    iter[val] = obj[val];\n                &#125;else &#123;\n                    iter = &#123;&#125;\n                &#125;\n                return iter;\n                &#125;, &#123;&#125;);\n        &#125;\n    &lt;/script>\n&lt;/body>\n&lt;/html>\n\n\n\n\n\n\n\n\n\n\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"Javascript-对象数组取差集和交集的方法","date":"2021-10-18T07:12:09.000Z","categories_index":"","tags_index":"Javascript","author_index":"JIARUI's BLOG"},{"id":"bba9207d0ca2df362550b15c323b2f7a","title":"UML语言的参考案例—基于plantuml","content":"\n\n\n\n\n\n\n\n\nUML(Unified modeling language) 是统一建模语言或者标准建模语言。通过使用 UML 的面向对象图的方式，可以更明确、清晰的表达项目中的架设思想、项目结构、执行顺序等一些逻辑思维。 \n本文基于plantuml阐述了uml语言的典型图。PlantUML语言简单直接易学，就好像Markdown语法一样，简单高效。\nplantuml 具有完善的支持网站 https://plantuml.com/zh/。\n拥有一个在线编辑工具：http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000\n时序图1.简单图你可以用-&gt;来绘制参与者之间传递的消息， 而不必显式地声明参与者。你也可以使用--&gt;绘制一个虚线箭头。另外，还能用 &lt;- 和 &lt;--，这不影响绘图，但可以提高可读性。 注意：仅适用于时序图，对于其它示意图，规则是不同的。\n@startuml\n用户 -&gt; 认证中心: 登录操作\n认证中心 -&gt; 缓存: 存放(key&#x3D;token+ip,value&#x3D;token)token\n\n用户 &lt;- 认证中心 : 认证成功返回token\n用户 -&gt; 认证中心: 下次访问头部携带token认证\n认证中心 &lt;- 缓存: key&#x3D;token+ip获取token\n其他服务 &lt;- 认证中心: 存在且校验成功则跳转到用户请求的其他服务\n其他服务 -&gt; 用户: 信息\n@enduml\n\n2.时序图下图展示了生命线的激活与撤销。关键字activate和deactivate用来表示参与者的生命活动。\n一旦参与者被激活，它的生命线就会显示出来。activate和deactivate适用于以上情形，destroy表示一个参与者的生命线的终结。\n@startuml\nparticipant User\n\nUser -&gt; A: DoWork\nactivate A #FFBBBB\n\nA -&gt; A: Internal call\nactivate A #DarkSalmon\n\nA -&gt; B: &lt;&lt; createRequest &gt;&gt;\nactivate B\n\nB --&gt; A: RequestCreated\ndeactivate B\ndeactivate A\nA -&gt; User: Done\ndeactivate A\n\n@enduml\n\n\n用例图1.用例用例用圆括号括起来。也可以用关键字usecase来定义用例。还可以用关键字as定义一个别名，这个别名可以在以后定义关系的时候使用。\n2.角色角色用两个冒号包裹起来，也可以用actor关键字来定义角色。\n@startuml\nskinparam actorStyle awesome\n:User: --&gt; (Use)\n&quot;Main Admin&quot; as Admin\n&quot;Use the application&quot; as (Use)\nAdmin --&gt; (Admin the application)\n@enduml\n\n\n3.打包图@startuml\nleft to right direction\nactor Guest as g\npackage Professional &#123;\n  actor Chef as c\n  actor &quot;Food Critic&quot; as fc\n&#125;\npackage Restaurant &#123;\n  usecase &quot;Eat Food&quot; as UC1\n  usecase &quot;Pay for Food&quot; as UC2\n  usecase &quot;Drink&quot; as UC3\n  usecase &quot;Review&quot; as UC4\n&#125;\nfc --&gt; UC4\ng --&gt; UC1\ng --&gt; UC2\ng --&gt; UC3\n@enduml\n\n\n4.完整例子箭头：用箭头--&gt;连接角色和用例。横杠-越多，箭头越长。 通过在箭头定义的后面加一个冒号及文字的方式来添加标签。\n继承：如果一个角色或者用例继承于另一个，那么可以用–&gt;符号表示。\n使用注释：可以用note left of , note right of , note top of , note bottom of等关键字给一个对象添加注释。注释还可以通过note关键字来定义，然后用..连接其他对象。\n@startuml\nleft to right direction\nskinparam packageStyle rectangle\nactor customer\nactor clerk\nrectangle checkout &#123;\n  customer -- (checkout)\n  (checkout) .&gt; (payment) : include\n  (help) .&gt; (checkout) : extends\n  (checkout) -- clerk\n&#125;\n@enduml\n\n\n类图1.类图元素@startuml\nabstract        abstract\nabstract class  &quot;abstract class&quot;\nannotation      annotation\ncircle          circle\n()              circle_short_form\nclass           class\ndiamond         diamond\n&lt;&gt;              diamond_short_form\nentity          entity\nenum            enum\ninterface       interface\n@enduml\n\n2.类之间的关系类之间的关系通过以下符号定义：\n\n\n\nType\nSymbol\nDrawing\n\n\n\nExtension(扩展)\n&lt;|–\n\n\n\nComposition(组合)\n*–\n\n\n\nAggregation(聚合)\no–\n\n\n\n@startuml\nClass01 &lt;|-- Class02\nClass03 *-- Class04\nClass05 o-- Class06\nClass07 .. Class08\nClass09 -- Class10\n@enduml\n\n2.示例为了生命对象属性或者方法，可以使用字段名或者方法名。系统通过是否有括号来判断是方法还是字段。使用{}把字段或者方法括起来。\n@startuml\nleft to right direction\nclass Dummy &#123;\n  String data\n  flightNumber : Integer\n  Integer function()\n&#125;\n\nclass Flight &#123;\n   flightNumber : Integer\n   departureTime : Date\n   Integer yyy(Date)\n&#125;\n\nFlight &lt;-- Dummy\n@enduml\n\n3.定义可访问性一旦定义了域或者方法，可以定义相应条目的可访问性质。\n\n\n\nCharacter\nIcon for field\nIcon for method\nVisibility\n\n\n\n-\n\n\nprivate\n\n\n#\n\n\nprotected\n\n\n~\n\n\npackage private\n\n\n+\n\n\npublic\n\n\n@startuml\n\nclass Dummy &#123;\n -field1\n #field2\n ~method1()\n +method2()\n&#125;\n\n@enduml\n\n\n活动图1.简单活动使用（*)作为活动图的开始点和结束点。有时可用(*top）强制开始点位于图示的顶端。\n@startuml\n\n(*) -up-&gt; &quot;First Activity&quot;\n-right-&gt; &quot;Second Activity&quot;\n--&gt; &quot;Third Activity&quot;\n-left-&gt; (*)\n\n@enduml\n\n\n2.分支活动可以使用关键字if/then/else创建分支。\n@startuml\n(*) --&gt; &quot;Initialization&quot;\n\nif &quot;Some Test&quot; then\n  --&gt;[true] &quot;Some Activity&quot;\n  --&gt; &quot;Another activity&quot;\n  -right-&gt; (*)\nelse\n  -&gt;[false] &quot;Something else&quot;\n  --&gt;[Ending process] (*)\nendif\n\n@enduml\n\n\n3.新特性@startuml\nstart\nif (condition A) then (yes)\n  :Text 1;\nelseif (condition B) then (yes)\n  :Text 2;\n  stop\nelseif (condition C) then (yes)\n  :Text 3;\nelseif (condition D) then (yes)\n  :Text 4;\nelse (nothing)\n  :Text else;\nendif\nstop\n@enduml\n\n\n组件图组件必须用中括号括起来。还可以使用关键字component定义一个组件。并且可以用关键字as给组件定义一个别名\n@startuml\n\n[First component]\n[Another component] as Comp2\ncomponent Comp3\ncomponent [Last\\ncomponent] as Comp4\n\n@enduml\n\n状态图简单图@startuml\n\n[*] --&gt; State1\nState1 --&gt; [*]\nState1 : this is a string\nState1 : this is another string\n\nState1 -&gt; State2\nState2 --&gt; [*]\n\n@enduml\n\n\n部署图略\n定时图@startuml\nscale 5 as 150 pixels\n\nclock clk with period 1\nbinary &quot;enable&quot; as en\nbinary &quot;R&#x2F;W&quot; as rw\nbinary &quot;data Valid&quot; as dv\nconcise &quot;dataBus&quot; as db\nconcise &quot;address bus&quot; as addr\n\n@6 as :write_beg\n@10 as :write_end\n\n@15 as :read_beg\n@19 as :read_end\n\n\n@0\nen is low\ndb is &quot;0x0&quot;\naddr is &quot;0x03f&quot;\nrw is low\ndv is 0\n\n@:write_beg-3\n en is high\n@:write_beg-2\n db is &quot;0xDEADBEEF&quot;\n@:write_beg-1\ndv is 1\n@:write_beg\nrw is high\n\n\n@:write_end\nrw is low\ndv is low\n@:write_end+1\nrw is low\ndb is &quot;0x0&quot;\naddr is &quot;0x23&quot;\n\n@12\ndv is high\n@13\ndb is &quot;0xFFFF&quot;\n\n@20\nen is low\ndv is low\n@21\ndb is &quot;0x0&quot;\n\nhighlight :write_beg to :write_end #Gold:Write\nhighlight :read_beg to :read_end #lightBlue:Read\n\ndb@:write_beg-1 &lt;-&gt; @:write_end : setup time\ndb@:write_beg-1 -&gt; addr@:write_end+1 : hold\n@enduml\n\n\nNetwork diagram待补充。\nSaltSalt 是 PlantUML 下面的子项目用来帮助用户来设计图形接口.\n@startsalt\n&#123;\n  Just plain text\n  [This is my button]\n  ()  Unchecked radio\n  (X) Checked radio\n  []  Unchecked box\n  [X] Checked box\n  &quot;Enter text here   &quot;\n  ^This is a droplist^\n&#125;\n@endsalt\n\n\n@startsalt\n&#123;\n&#123;T\n + World\n ++ America\n +++ Canada\n +++ USA\n ++++ New York\n ++++ Boston\n +++ Mexico\n ++ Europe\n +++ Italy\n +++ Germany\n ++++ Berlin\n ++ Africa\n&#125;\n&#125;\n@endsalt\n\n\nGantt Diagram@startgantt\n[Prototype design] lasts 15 days\n[Test prototype] lasts 10 days\n-- All example --\n[Task 1 (1 day)] lasts 1 day\n[T2 (5 days)] lasts 5 days\n[T3 (1 week)] lasts 1 week\n[T4 (1 week and 4 days)] lasts 1 week and 4 days\n[T5 (2 weeks)] lasts 2 weeks\n@endgantt\n\n\n思维导图同时兼容OrgMode语法。\n@startmindmap\n* Debian\n** Ubuntu\n*** Linux Mint\n*** Kubuntu\n*** Lubuntu\n*** KDE Neon\n** LMDE\n** SolydXK\n** SteamOS\n** Raspbian with a very long name\n*** &lt;s&gt;Raspmbc&lt;&#x2F;s&gt; &#x3D;&gt; OSMC\n*** &lt;s&gt;Raspyfi&lt;&#x2F;s&gt; &#x3D;&gt; Volumio\n@endmindmap\n\n\n\n\nWork Breakdown Structure (WBS)略，待补充。\n更多内容见uml官网。\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！\n更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"UML语言的参考案例—基于plantuml","date":"2021-09-30T14:40:08.000Z","categories_index":"","tags_index":"","author_index":"JIARUI's BLOG"},{"id":"f9f8ad73583ebb207dcfcb73d78ba8ed","title":"UML建模工具PlantUML的使用办法","content":"\n\n\n\n\n\n\n\n\nUML(Unified modeling language) 是统一建模语言或者标准建模语言。通过使用 UML 的面向对象图的方式，可以更明确、清晰的表达项目中的架设思想、项目结构、执行顺序等一些逻辑思维。 \n1.在VScode中使用PlantUML首先在VScode中安装插件plantuml。\n在Plantuml中我们使用伪编程语言来生成图表。代码的文件的扩展名包括了如下几种类型：*.wsd, *.pu, *.puml, *.plantuml, *.iuml。按Alt+D或者Option+D可预览生成的图表。注意如果你的电脑上没有安装java需要进行安装\n2.在IDEA中使用PlantUML在IDEA中使用安装插件的方法，搜索如下的插件进行安装。除了Plant UML Integration以外，剩余两个插件可以帮助我们更好的使用plantuml。\n有了插件，我们可以新建PlantUML的新图。如果不能执行这步操作说明PlantUML没有安装成功，可以进一步检查。新建的图类型包括了：时序图、状态图、组件图、甘特图、脑图等等类型的图。\n在新建的图中，PlantUML会为我们创建一些示例的代码，我们在示例代码基础上进行修改就可以变成我们期望的图。在编辑代码的区域右侧会出现PlantUML的选项，点击该选项可以看到实时渲染的UML图。\n以上关于PlantUML语言的使用仅限于Windows系统。\n3.在线编辑器PlantUMLPlantUML提供PlantUML Server。该工具可以生成PNG, SVG 或 LaTeX 格式的图片。 也可以生成 ASCII艺术图 (只针对时序图)。\n参考文档：https://www.jianshu.com/p/5c7bc062aa2bhttps://www.jianshu.com/p/6c4071eac339\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！\n更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"UML建模工具PlantUML的使用办法","date":"2021-09-30T14:29:49.000Z","categories_index":"","tags_index":"","author_index":"JIARUI's BLOG"},{"id":"04b0e5a619aba169acfb000247466025","title":"基于百度云AI开发车型识别车牌识别案例详解","content":"关键字： 车牌识别 车型识别 百度AI SpringBoot Vue Java SDK\n@[toc]\n1.创建百度AI应用\n进入百度AI官网https://ai.baidu.com/，点击右上角控制台，用百度账号登录。如果没有百度账号，需要首先创建一个百度账号。\n在控制台可以看到各种百度提供的AI应用接口。找到需要的应用接口，点进去可以创建一个相应的应用。\n图像识别提供一个组合API接口，支持多种垂类识别服务的灵活组合调用。\n然后会提供给该应用一个API Key 和Secret Key，它是我们调用接口必须的两个参数。\n以下是本次开发中用到的车型识别的应用。百度AI的车牌识别需要另外申请一个应用。需要注意的是不同的应用有不同的AppID等参数。\n\n2.通过Access_token密码调用百度AI接口（车型识别）\n车型识别功能检测图片中的车辆，识别具体车型，包括车辆品牌体型号、颜色、年份、位置信息。\n车辆识别为例。它的请求url为： https://aip.baidubce.com/rest/2.0/image-classify/v1/car\n调用方式一定为POST。同时我们要在后面添加以下参数：\naccess_token：即前面获取的密码\n在请求头中设置Content-Type参数\nContent-Type：设置为application/x-www-form-urlencoded\n在请求体Body中设置image图片的信息参数\n1.image：图片信息参数，它是通过图片路径找到图片转为字节，然后经过Base64编码最后形成的字符串。如下代码\n&#x2F;&#x2F;获取图片的路径\nString filePath &#x3D; Path;\n\n&#x2F;&#x2F;将图片转为字节数组\nbyte[] imgData &#x3D; FileUtil.readFileByBytes(filePath);\n\n&#x2F;&#x2F;将图片字节数组转为Base64编码的字符串换\nString imgStr &#x3D; Base64Util.encode(imgData);\n\n&#x2F;&#x2F;将经过Base64编码的图片字符串转为UTF-8编码的字符串。可以直接传给image参数\nString imgParam &#x3D; URLEncoder.encode(imgStr, &quot;UTF-8&quot;);\n2.top_num：设置返回的信息的数量，默认5，因为车辆识别会得出多个结果，按几率得到，我们可以获取前n个的数据\n3.baike_num：设置返回的百科的信息数，默认不返回\n3.Java客户端AipImageClassifyClient调用AI接口\n以上方法是采用接口直接调用，下面的方法是使用JAVA客户端进行访问。首先需要安装ImageClassify Java SDK，可以在官方网站下载Java SDK压缩工具包。\n\n然后，新建AipImageClassifyClient，AipImageClassifyClient是图像识别的Java客户端，为使用图像识别的开发人员提供了一系列的交互方法。\n用户可以参考如下代码新建一个AipImageClassifyClient,初始化完成后建议单例使用,避免重复获取access_token：\npublic class Sample &#123;\n    //设置APPID/AK/SK\n    public static final String APP_ID = \"你的 App ID\";\n    public static final String API_KEY = \"你的 Api Key\";\n    public static final String SECRET_KEY = \"你的 Secret Key\";\n\n    public static void main(String[] args) &#123;\n        // 初始化一个AipImageClassifyClient\n        AipImageClassifyClient client = new AipImageClassifyClient(APP_ID, API_KEY, SECRET_KEY);\n\n        // 可选：设置网络连接参数\n        client.setConnectionTimeoutInMillis(2000);\n        client.setSocketTimeoutInMillis(60000);\n\n        // 可选：设置代理服务器地址, http和socket二选一，或者均不设置\n        client.setHttpProxy(\"proxy_host\", proxy_port);  // 设置http代理\n        client.setSocketProxy(\"proxy_host\", proxy_port);  // 设置socket代理\n\n        // 调用接口\n        String path = \"test.jpg\";\n        JSONObject res = client.objectDetect(path, new HashMap&lt;String, String>());\n        System.out.println(res.toString(2));\n        \n    &#125;\n&#125;\n\n在上面代码中，常量APP_ID在百度智能云控制台中创建，常量API_KEY与SECRET_KEY是在创建完毕应用后，系统分配给用户的，均为字符串，用于标识用户，为访问做签名验证，可在AI服务控制台中的应用列表中查看。\n4.车型识别接口说明\n识别图片中车辆的具体车型，可识别常见的3000+款车型（小汽车为主），输出车辆的品牌型号、颜色、年份、位置信息；支持返回对应识别结果的百度百科词条信息，包含词条名称、百科页面链接、百科图片链接、百科内容简介。\n当前只支持单主体识别，若图片中有多个车辆，则识别目标最大的车辆。\n百度官方文档提供了调用的示例，提交参数的方式有本地路径和二进制数组。\npublic void sample(AipImageClassify client) &#123;\n    &#x2F;&#x2F; 传入可选参数调用接口\n    HashMap&lt;String, String&gt; options &#x3D; new HashMap&lt;String, String&gt;();\n    options.put(&quot;top_num&quot;, &quot;3&quot;);\n    options.put(&quot;baike_num&quot;, &quot;5&quot;);\n\n\n    &#x2F;&#x2F; 参数为本地路径\n    String image &#x3D; &quot;test.jpg&quot;;\n    JSONObject res &#x3D; client.carDetect(image, options);\n    System.out.println(res.toString(2));\n\n    &#x2F;&#x2F; 参数为二进制数组\n    byte[] file &#x3D; readFile(&quot;test.jpg&quot;);\n    res &#x3D; client.carDetect(file, options);\n    System.out.println(res.toString(2));\n&#125;\n\n\n\n车型识别 请求参数详情\n\n\n\n参数名称\n是否必选\n类型\n默认值\n说明\n\n\n\nimage\n是\nmixed\n-\n本地图片路径或者图片二进制数据\n\n\ntop_num\n否\nString\n5\n返回预测得分top结果数，默认为5\n\n\nbaike_num\n否\nString\n0\n返回百科信息的结果数，默认不返回\n\n\n车型识别 返回数据参数详情\n\n\n\n字段\n是否必选\n类型\n说明\n\n\n\nlog_id\n是\nuint64\n唯一的log id，用于问题定位\n\n\ncolor_result\n是\nstring\n车身颜色\n\n\nresult\n是\ncar-result()\n车型识别结果数组\n\n\n+name\n是\nstring\n车型名称，示例：宝马x6\n\n\n+score\n是\ndouble\n置信度，取值范围0-1，示例：0.5321\n\n\n+year\n是\nstring\n年份\n\n\n+baike_info\n否\nobject\n对应识别结果的百科词条名称\n\n\n++baike_url\n否\nstring\n对应识别结果百度百科页面链接\n\n\n++image_url\n否\nstring\n对应识别结果百科图片链接\n\n\n++description\n否\nstring\n对应识别结果百科内容描述\n\n\nlocation_result\n是\nstring\n车辆在图片中的位置信息\n\n\n+width\n是\nfloat\n车辆区域的宽度\n\n\n+height\n是\nfloat\n车辆区域的高度\n\n\n+left\n是\nfloat\n车辆区域离左边界的距离\n\n\n+top\n是\nfloat\n车辆区域离上边界的距离\n\n\n车型识别 返回示例\n&#123;\n  \"log_id\": 4086212218842203806,\n  \"location_result\": &#123;\n    \"width\": 447,\n    \"top\": 226,\n    \"height\": 209,\n    \"left\": 188\n  &#125;,\n  \"result\": [&#123;\n    \"baike_info\": &#123;\n      \"baike_url\": \"http://baike.baidu.com/item/%E5%B8%83%E5%8A%A0%E8%BF%AAChiron/20419512\",\n      \"description\": \"布加迪Chiron是法国跑车品牌布加迪出品的豪华超跑车。配置四涡轮增压发动机，420 公里每小时，有23种颜色的选择，售价高达260万美元。\"\n    &#125;,\n    \"score\": 0.98793351650238,\n    \"name\": \"布加迪Chiron\",\n    \"year\": \"无年份信息\"\n  &#125;,\n  &#123;\n    \"score\": 0.0021970034576952,\n    \"name\": \"奥迪RS5\",\n    \"year\": \"2011-2017\"\n  &#125;,\n  &#123;\n    \"score\": 0.0021096928976476,\n    \"name\": \"奥迪RS4\",\n    \"year\": \"无年份信息\"\n  &#125;,\n  &#123;\n    \"score\": 0.0015581247862428,\n    \"name\": \"奥迪RS7\",\n    \"year\": \"2014-2016\"\n  &#125;,\n  &#123;\n    \"score\": 0.00082337751518935,\n    \"name\": \"布加迪威航\",\n    \"year\": \"2004-2015\"\n  &#125;],\n  \"color_result\": \"颜色无法识别\"\n&#125;\n\n\n\n车型识别的错误码可见：https://ai.baidu.com/ai-doc/VEHICLE/Gk3hb3ifo\n⚠ 车牌识别的调用方式和以上车型识别的方式大同小异，这里略过。\n5.Java后端Controller层接收图片\n本次开发的后端应用基于SpringBoot v2.4.1，Controller层的开发内容如下所示。\n/**\n * @Author Jarrett Luo\n * @Date 2021/1/28 18:26\n * @Version 1.0\n */\n@RestController\n@RequestMapping(value = \"/recognition\")\npublic class RecognitionController &#123;\n    \n    @Resource\n    RecognitionService recognitionService;\n    \n    @CrossOrigin\n    @PostMapping\n    public ApiResult save(@RequestParam(value=\"file\", required=false) MultipartFile multipartFile)\n            throws IOException &#123;\n        byte[] imgBytes = multipartFile.getBytes();\n        if(imgBytes!=null)&#123;\n            return recognitionService.find(imgBytes);\n        &#125;\n        else &#123;\n            return ApiResult.error(201,\"数据为空!\");\n        &#125;\n    &#125;\n&#125;\n\nbyte[] imgBytes = multipartFile.getBytes();将前端传递的数据转换为二进制数组，以便于后面进行调用。\n必须进行非空判断后才能进入下一步，否则会出现没有返回值的错误。ApiResult是自己写的一个工具，用于返回结果，如果传入的空数据，则返回201的错误码。\n6.Java后端Service层访问AI接口\n根据百度AI控制页创建的应用，设置每个应用的APP_ID, API_KEY, SECRET_KEY。这里需要注意的是百度AI提交的不同接口需要创建不同的应用。\n我们对文件的大小进行了限制，这里仅处理10MB以下的图片。\npublic ApiResult find(byte[] image) &#123;\n        if(image.length>10048575) &#123;\n            return ApiResult.error(201, \"文件过大！\");\n        &#125;\n        // 初始化一个AipOcr\n        AipOcr client = new AipOcr(APP_ID, API_KEY, SECRET_KEY);\n        HashMap&lt;String, String> options = new HashMap&lt;String, String>();\n\n        JSONObject res = client.plateLicense(image, options);\n        String number;\n\n        if(res.has(\"words_result\")) &#123;\n            JSONObject jsonData = res.getJSONObject(\"words_result\");\n            number = jsonData.getString(\"number\");\n        &#125;else &#123;\n            number = null;\n        &#125;\n\n        // 初始化一个AipImageClassify\n        AipImageClassify client1 = new AipImageClassify(APP_ID_1, API_KEY_1, SECRET_KEY_1);\n\n        // 传入可选参数调用接口\n        HashMap&lt;String, String> options1 = new HashMap&lt;String, String>();\n        options.put(\"top_num\", \"1\");\n\n        // 参数为本地路径\n        JSONObject res1 = client1.carDetect(image, options1);\n        String color;\n        String name;\n        String year;\n        if(res1.has(\"result\")) &#123;\n            JSONArray jsonData = res1.getJSONArray(\"result\");\n            JSONObject vehicle = jsonData.getJSONObject(0);//获取数组第一个元素\n            year = vehicle.getString(\"year\");\n            name = vehicle.getString(\"name\");\n            color = res1.getString(\"color_result\");\n            if(year.equals(\"无年份信息\"))&#123;\n                year = null;\n            &#125;\n            if(name.equals(\"非车类\")) &#123;\n                name = null;\n            &#125;\n            if(color.equals(\"无车辆颜色信息\")) &#123;\n                color = null;\n            &#125;\n        &#125;else &#123;\n            year = null;\n            name = null;\n            color = null;\n        &#125;\n\n        RecognitionDTO recognitionDTO = new RecognitionDTO(number,\n                name,\n                year,\n                color);\n        return ApiResult.success(recognitionDTO);\n    &#125;\n\n注意以上代码的ApiResult是自己写的一个结果转换的工具类。关于ApiResult的详细内容可以查看作者github的详细介绍。\n7.基于VUE的前端开发车牌识别和车型识别\n根据开发需求，在页面中增加一个拍照自动识别按钮，用户点击按钮后可以选择拍照或者相册中的照片。相应的HTML代码如下所示。\n\n/**\n * 图片拍照识别上传\n * @author: 罗佳瑞\n */\nuploadFile() &#123;\n    var that = this;\n    var inputDOM = that.$refs.imageInput;\n    var file = inputDOM.files;\n    var formData = new FormData();\n    formData.append('file', file[0]);\n    this.uploadImage(formData)\n\n    Indicator.open(&#123;\n        text: '识别中...',\n        spinnerType: 'fading-circle'\n    &#125;);\n    setTimeout(()=>&#123;\n        Indicator.close();\n    &#125;,15000)\n&#125;,\n\n以下是采用异步方式提交数据到后台服务器，提交数据的函数时recorgnizeRequest。如果成功返回数据该函数将回调uploadImageResult，关于该回调函数下文将会介绍。\n/**\n* 异步提交数据到后台\n* @author: 罗佳瑞\n*/\nasync uploadImage(formData) &#123;\n      await vehiclePageRequest.recorgnizeRequest(formData)\n          .then(res => &#123;\n          this.uploadImageResult(res)\n      &#125;)\n          .catch(err => &#123;\n          Toast(\"\" + err)\n      &#125;)\n&#125;,\n\n\n\n采用axios提交数据到相应的URL。VUE中采用Promise提交数据，采用这种方式提交更好的看到提交成功和识别的结果。特别要注意，为了避免axios对formdata进行转换，因此最好加上tansformRequest。\nfunction recorgnizeRequest(FormData) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        axios(&#123;\n            url: RECORGNIZE_URL,\n            method: &#39;POST&#39;,\n            headers: &#123;\n                &#39;Content-Type&#39;: &quot;multipart&#x2F;form-data&quot;,\n                &#x2F;&#x2F; token: sessionStorage.getItem(&#39;token&#39;)\n            &#125;,\n            &#x2F;&#x2F;这部分非常重要，否则formdata会被转格式\n            transformRequest: [function()&#123;\n                return FormData;\n            &#125;],\n            params: &#123;&#125;,\n            data: FormData,\n        &#125;)\n        .then((res) &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 成功\n            resolve(res.data)\n        &#125;)\n        .catch((res) &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 失败\n            reject(res)\n        &#125;)\n    &#125;)\n&#125;\n\n后端返回的数据采用如下代码映射到表单中。由于返回的结果中可能没有识别到车辆，或者图片中没有车辆信息，因此在这一步进行非空判断。\nIndicator是前端框架的指示器，用于告知用户当前识别进度以及识别结果。\nuploadImageResult(res) &#123;\n    if(res.code&#x3D;&#x3D;200) &#123;\n        var recorgnizeResult &#x3D; res.data\n        var rln &#x3D; recorgnizeResult.licenseNumber\n        var rvb &#x3D; recorgnizeResult.name\n        var rvc &#x3D; recorgnizeResult.color;\n        var rvy &#x3D; recorgnizeResult.year;\n\n        var resultStr &#x3D; &quot;&quot;;\n        if(rln!&#x3D;null)&#123;\n            this.vehicleInfo.vehiclePlate &#x3D; rln;\n            resultStr &#x3D; resultStr + &quot;车牌可能是：&quot; + rln + &quot;;\\n&quot;\n        &#125;\n        if(rvb!&#x3D;null) &#123;\n            this.vehicleInfo.vehicleBrand &#x3D; rvb;\n            resultStr &#x3D; resultStr + &quot;品牌可能是：&quot; + rvb + &quot;;\\n&quot;\n        &#125;\n\n        if(rvc!&#x3D;null) &#123;\n            this.vehicleInfo.vehicleColor &#x3D; rvc;\n            resultStr &#x3D; resultStr + &quot;颜色可能是：&quot; + rvc + &quot;;\\n&quot;\n        &#125;\n        if(rvy!&#x3D;null) &#123;\n            var rvyFormat &#x3D; rvy.substr(0,4)\n            resultStr &#x3D; resultStr + &quot;年代可能是：&quot; + rvyFormat + &quot;年;\\n&quot;\n        &#125;\n\n        Indicator.close();\n        Indicator.open(&#123;\n            text: &quot;识别成功\\n&quot; + resultStr,\n            spinnerType: &#39;fading-circle&#39;\n        &#125;);\n        setTimeout(()&#x3D;&gt;&#123;\n            Indicator.close();\n        &#125;,7500)\n\n    &#125;else&#123;\n        Toast(&#123;\n            message: &quot;连接超时！&quot;\n        &#125;)\n    &#125;\n&#125;\n\n前端页面开发结果如下。用户点击拍照自动识别后，选择拍照或者相册，提交照片等待返回结果。\n服务器返回的结果会自动输入到下图中的车牌号，汽车品牌，车身颜色。\n\n8.总结与展望\n\n本文从访问百度AI接口出发，详细阐述了后端如何调用百度接口，实现一次图片上传得到车牌识别和车型识别的结果。\n\n本文的前端开发作为示例，提供了一种思路，更多的如客户端，安卓，IOS应用等等都可以采用如此方法开发。\n\n采用百度AI提供的接口，可以拓展更多丰富的应用；多种接口的叠加让用户一次上传便得到多种结果。\n\n通过成熟的AI算法，识别的准确度和速度都比较令人满意。\n\n以上过程中存在的不足是，由于用户拍照后直接上传的图片是比较大的，导致在传输过程中比较慢，甚至会出现超时的情况，用户体验不够好。改进的方法是前端页面首先对大文件进行压缩后再上传。\n\n百度AI提供了组合调用AI的方式，前端可以采用该种方式发起请求。在此应用中需要保存用户的图片，因此没有采用该方式。\n\n\n\n\n\n\n\n\n\n\n\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"基于百度云AI开发车型识别车牌识别案例详解","date":"2021-09-30T14:24:18.000Z","categories_index":"应用案例","tags_index":"Java,Api","author_index":"JIARUI's BLOG"},{"id":"09ee25fa4eddcb001db0d1eba194cd72","title":"Swagger与RestFul集成并导入Postman测试","content":"使用教程：Springboot + Swagger3 集成和配置\nmaven依赖&lt;dependencies>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>io.springfox&lt;/groupId>\n            &lt;artifactId>springfox-boot-starter&lt;/artifactId>\n            &lt;version>3.0.0&lt;/version>\n        &lt;/dependency>\n&lt;/dependencies>\n添加注解@SpringBootApplication\n@EnableOpenApi\npublic class DemoSwagger3Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(DemoSwagger3Application.class, args);\n    &#125;\n&#125;\n\n访问swagger使用浏览器访问如下页面：http://localhost:8081/swagger-ui/index.html#/\n\n更改为第三方UI&lt;dependency>\n    &lt;groupId>com.github.xiaoymin&lt;/groupId>\n    &lt;artifactId>swagger-bootstrap-ui&lt;/artifactId>\n    &lt;version>1.9.6&lt;/version>\n&lt;/dependency>\n必须从以下地址进行访问！http://localhost:8081/doc.html\n\nSwagger能够自动将api文档导入到POSTMAN进行测试！通过swagger将接口导入postman教程\n\n\n\n\n\n\n\n\n\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"Swagger与RestFul集成并导入Postman测试","date":"2021-09-30T14:21:10.000Z","categories_index":"","tags_index":"Java","author_index":"JIARUI's BLOG"},{"id":"d458460d4e8352a87dca6136bc68fc00","title":"解决Slf4J报错：Class path contains multiple SLF4J bindings","content":"在运行Springboot的时候，出现Class path contains multiple SLF4J bindings报错信息，以下是排查思路和解决方案。\nSLF4J: Class path contains multiple SLF4J bindings.\nSLF4J: Found binding in [jar:file:&#x2F;D:&#x2F;maven_repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.2.3&#x2F;logback-classic-1.2.3.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]\nSLF4J: Found binding in [jar:file:&#x2F;D:&#x2F;maven_repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-simple&#x2F;1.7.30&#x2F;slf4j-simple-1.7.30.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]\nSLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.\nSLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]\n\n\n参考的解决方案：[已解决] SLF4J: Class path contains multiple SLF4J bindings\n开始解决该问题：既然是冲突，那可能就是项目中依赖了多个不同版本的slf4j类库，那如何分析到底是哪几个类库依赖了slf4j呢？我们可以使用dependency:tree命令：\n$ mvn dependency:tree\n\n\n我的项目中引入了百度的API，所以重点从新加入的包中寻找解决方案。找到百度中引入的API依赖出现冲突，将其去掉即可了。\n&lt;dependency>\n\t&lt;groupId>com.baidu.aip&lt;/groupId>\n\t&lt;artifactId>java-sdk&lt;/artifactId>\n\t&lt;version>4.15.3&lt;/version>\n\t&lt;exclusions>\n\t\t&lt;exclusion>\n\t\t\t&lt;groupId>org.springframework&lt;/groupId>\n\t\t\t&lt;artifactId>spring&lt;/artifactId>\n\t\t&lt;/exclusion>\n            &lt;exclusion>\n\t\t\t&lt;groupId>org.slf4j&lt;/groupId>\n\t\t\t&lt;artifactId>slf4j-log4j12&lt;/artifactId>\n\t\t&lt;/exclusion>\n\t\t&lt;exclusion>\n\t\t\t&lt;groupId>org.slf4j&lt;/groupId>\n\t\t\t&lt;artifactId>slf4j-simple&lt;/artifactId>\n\t\t&lt;/exclusion>\n\t&lt;/exclusions>\n&lt;/dependency>\n\n最终顺利启动项目。\n\n\n\n\n\n\n\n\n\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"解决Slf4J报错：Class-path-contains-multiple-SLF4J-bindings","date":"2021-09-30T14:16:11.000Z","categories_index":"debug","tags_index":"Java,Slf4J","author_index":"JIARUI's BLOG"},{"id":"000f3c9891d15d2751df6a8f7d53d20c","title":"Maven 基础概念及应用方法","content":"Maven基础概念Project:任何你想构建的事务Maven都可以认为它们是工程，这些工程被定义为工程对象模型（project Object Model POM） 一个工程可以依赖其他的工程，一个工程也可以由多个子工程构成\nPOM：POM(pom.xml) 是Maven 的核心文件，它是只是Maven如何工作的元数据文件。POM文件位于每个工程的根目录中。\nGroupId:GroupId是一个工程在全局中的唯一标识符，一般地，他就是工程名，GroupId有利于使用一个完全的包名将一个工程从其他有类似名称的工程中区别出来。\nArtifact:中文名为”构件”,是工程将要生产或需要使用的文件，它可以是.jar文件,源文件，二进制文件，.war文件，甚至是.pom文件。每个Artifact都要放在仓库（Repository）中，否则Maven无法找到它们。\nDependency：为了能够构建或运行,一个典型的Java工程都会依赖其他的包，在Maven中,这些被依赖的包就被称为Dependency。Dependency一般是其他工程的Artifact。\nPlug-in: 可以说Maven就是一堆插件的集合，它的每一个功能都是由插件完成的，插件提供goal(类似于Ant中的target),并根据在POM中找到的元数据去完成工作。主要的Maven插件是由Java编写而成的，同时支持用beanshell或Ant脚本编写的插件。\nRepository:仓库，即放置Artifact的地方，有中央仓库，公共仓库，私有仓库及本地仓库之分。为了提高Artifact的下载速度，一般情况下，公司或开发者组织都需要部署一个私有仓库，可以使用Nexus创建Maven私有仓库。\n如何应用在IDEA中设置maven，特别注意Maven的安装地址。根据个人的设置不同选择相应的Setting文件和仓库地址\nsetting.xml 设置为了更快地访问到maven中引用的库，那么需要修改镜像源。如下提供的是阿里云的镜像源设置方法，将这段代码拷贝到原有的setting.xml文件中即可。\n&lt;mirrors>\n    &lt;mirror>\n      &lt;id>alimaven&lt;/id>\n      &lt;mirrorOf>central&lt;/mirrorOf>\n      &lt;name>aliyun maven&lt;/name>\n      &lt;url>http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url>\n    &lt;/mirror>\n  &lt;/mirrors>\n\n参考资料什么是maven\n","slug":"Maven-基础概念及应用方法","date":"2021-09-30T14:14:53.000Z","categories_index":"","tags_index":"Java","author_index":"JIARUI's BLOG"},{"id":"91f86929902f90b68161fa3c7fea1edb","title":"Java开发案例：电脑自动开关机和爬取网页","content":"前言： 以下案例来自于开课吧公开课教程，以下代码用于记录和参考，无其他意图。\ndemo1: 电脑自动关机，和取消自动关机\n\n\n\n\n\n\n\n\n要求是使用代码对电脑进行控制，能够实现电脑开机和关机的操作。\n实现代码如下，分别能够进行自动关机和取消自动关机。\npackage com.kkb.demo;\nimport java.io.IOException;\n\npublic class Demo1 &#123;\n    public static void main(String[] args) throws IOException &#123;\n           &#x2F;&#x2F; 自动关机的程序，倒计时3600秒\n          Runtime.getRuntime().exec(&quot;shutdown -s -t 3600&quot;);\n          &#x2F;&#x2F; 取消自动关机\n          Runtime.getRuntime().exec(&quot;shutdown -a&quot;);\n    &#125;\n&#125;\n\ndemo2： 读取网址的内容\n\n\n\n\n\n\n\n\n该功能是采用Java的内置库实现对网页的访问。使用内置库URL连接网页，并逐行读取网页的内容。\n该demo能够拓展为爬虫功能。\npackage com.kkb.demo;\n\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class Demo1 &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F; 先创建一个网址工具URL的对象，ul\n        URL ul &#x3D; new URL(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);\n        &#x2F;&#x2F; 通过工具url， 连接网络，并得到连接工具conn\n        URLConnection conn &#x3D; ul.openConnection();\n        &#x2F;&#x2F; 获取到用于加载资源的 输入流\n        InputStream is &#x3D; conn.getInputStream();\n        &#x2F;&#x2F; 将输入is，装饰为能读取文字，且可以一次读取一行的缓存字符串\n        BufferedReader br &#x3D; new BufferedReader(\n                new InputStreamReader(is)\n        );\n        &#x2F;&#x2F; 读取一行资源\n        String text &#x3D; br.readLine();\n        &#x2F;&#x2F; 显示资源\n        System.out.println(text);\n        &#x2F;&#x2F; 关闭\n        br.close();\n    &#125;\n&#125;\n\n更多代码请访问作者博客：http://jiaruiblog.com\n欢迎点赞、转发、分享~\n","slug":"Java开发案例：电脑自动开关机和爬取网页","date":"2021-09-30T14:13:55.000Z","categories_index":"","tags_index":"Java","author_index":"JIARUI's BLOG"},{"id":"a4109aa5039151282f65b788222ecfd7","title":"如何修改mysql数据库表？","content":"\n\n\n\n\n\n\n\n\n当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。\n1、 变更表的字段信息：\n删除字段AALTER TABLE TEST_TABLE DROP A;\n添加字段并指定类型ALTER TABLE TEST_TABLE ADD B INT;\n修改字段类型ALTER TABLE TEST_TALBE MODIFY B CHAR(10);\n修改字段名及类型ALTER TABLE TEST_TABLE CHANGE B B_NEW BIGINT;\n修改字段默认值ALTER TABLE TEST_TABLE ALTER i SET DEFAULT 1000;\n\n2、修改表信息\n修改表名ALTER TABLE TEST_TABLE RENAME TO TEST_TABLE1;\n修改表注释ALTER TABLE TEST_TABLE COMMENT &quot;TEST TABLE FOR TEST&quot;;\n相关链接： \nCSDN ：Mysql修改字段名、修改字段类型\n\n菜鸟教程 ：MySQL ALTER命令\n\n更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n修改某个字段的时候注意要编辑其为utf-8编码 alter table operation_log modify params varchar(1024) character set utf8;\nMysql 如何导出文件和导入文件的方法如下所示：\n","slug":"如何修改mysql数据库表？","date":"2021-09-28T14:39:34.000Z","categories_index":"Mysql,Java","tags_index":"Java,Mysql","author_index":"JIARUI's BLOG"},{"id":"bcf04d24518831441ca514e6601ac96f","title":"axios 传递数组参数的方法","content":"axios不能传递数组参数，那么我们就通过以下方法来解决。网上能提供千奇百怪的方法，但是我认为这个是最简单的。\nlet arr &#x3D; [1,2,3]\naxios(&#123;url: &#39;&#x2F;user&#x2F;&#39;,\n    params: &#123;\n        id: arr + &#39;&#39;,    &#x2F;&#x2F; 重点在这数组加上&#39;&#39;,即可变为 &quot;1,2,3&quot;\n    &#125;\n&#125;\n所形成的url为： /user?id=1,2,3    等价于 /user?id=1&amp;id=2&amp;id=3\n后端接收参数的时候，用字符串类型进行接收，然后再转为列表。\n@CrossOrigin\n@GetMapping()\npublic ApiResult list(@RequestParam(&quot;companyId&quot;) Long companyId, @RequestParam(&quot;userId&quot;) String userList)\n    &#123;\n        String str[] &#x3D; userList.split(&quot;,&quot;);\n        List&lt;String&gt; userNameList &#x3D; Arrays.asList(str);\n        return operationLogService.list(companyId, userNameList);\n    &#125;\n\n看高招https://www.jianshu.com/p/68d81da4e1ad我尝试了链接里的方法，但是好像不管用。\n\n\n\n\n\n\n\n\n\n如果您觉得上面的内容对您有帮助欢迎点赞、评论、转发！更多内容请查阅作者博客：https://jiaruiblog.com或者star作者github: https://github.com/Jarrettluo?tab=repositories\n","slug":"axios-传递数组参数的方法","date":"2021-09-09T14:51:49.000Z","categories_index":"前端开发","tags_index":"Javascript","author_index":"JIARUI's BLOG"},{"id":"298d59cd4601f0011de521c9a83567d3","title":"Alibaba Cloud Toolkit工具使用教程","content":"\n\n\n\n\n\n\n\n\nAlibaba Cloud Toolkit（后文简称Cloud Toolkit）可以帮助开发者更高效地部署、测试、开发和诊断应用。\n传统部署方式在传统部署方式中，需要多个步骤才能完成应用的部署，并且需要在本地IDE、云产品控制台、Git/SVN、Maven/Gradle、镜像仓库、ECS、容器等多个界面间来回切换操作。\n\nCloud Toolkit部署方式Cloud Toolkit将项目构建、SCP上传部署包、制作Docker Image、登录机器、推送至镜像仓库等多个步骤进行了集成和简化，并针对阿里云服务进行了定制优化。\n\nVsCode使用 Alibaba Cloud ToolKit工具\n首先在插件市场安装 Alibaba Cloud Toolkit插件\n添加主机\n上传文件\n\n调试终端\n","slug":"Alibaba-Cloud-Toolkit工具使用教程","date":"2021-09-06T02:41:48.000Z","categories_index":"","tags_index":"web tool","author_index":"JIARUI's BLOG"},{"id":"40aa6f67d5b5ee71766450f293f6977e","title":"python实现自动发送天气预报到邮箱","content":"author：Jarrett初稿时间：2020年10月8日\n前言假如有个私人助理每天向我报告我所关心信息，比如我想知道今天的热点新闻，知乎、微博的热点内容，某个技术有了什么新的突破等等信息。但是，没有真人的“私人助理”但是可以有一个程序来帮我做到以上的事情。一个运行在服务端的程序，每天抓取我想要的信息，再定时地发送我的邮箱，这不就让梦想更进一步了。那就先来完成一个自动发送天气预报的程序，再将这个程序部署在树莓派上，设置为每天早上和下午定时发送到邮箱。\n天气数据的获取api提供商和风天气和风天气的开发者文档地址为：https://dev.heweather.com/docs/api/weather\n和风天气支持提供某个地区的天气预报和实况天气信息。其城市级天气预报API，包括全球15万个城市或地区的1-15天天气预报、实况天气、逐小时天气预报以及日出日落、月升月落等数据。和风天气提供的API包括商业版和开发版。\n\n\n\n\n\n\n\n\n\n如需要查看更早期的版本的开发文档请访问 S6版本，S6版本的技术支持截止于2020年6月1日。\n# 3天预报 HTTP GET\n\n$ 商业版 https:&#x2F;&#x2F;api.heweather.net&#x2F;v7&#x2F;weather&#x2F;3d?&#123;请求参数&#125;\n$ 开发版 https:&#x2F;&#x2F;devapi.heweather.net&#x2F;v7&#x2F;weather&#x2F;3d?&#123;请求参数&#125;\n\npython链接和风天气url = APIURL + '?location= ' + CITY + '&amp;key=' + KEY\nres = requests.get(url)\nres = json.loads(res.text)  # Change the response to json.\n\n和风天气的返回数据如下所示。\n&#123;\"HeWeather6\":\n[&#123;\"basic\":\n&#123;\"cid\":\"CN101271503\",\"location\":\"彭山\",\"parent_city\":\"眉山\",\"admin_area\":\"四川省\",\"cnty\":\"中国\",\"lat\":\"30.19229889\",\"lon\":\"103.87010193\",\"tz\":\"+8.00\"&#125;,\n\"update\": &#123;\"loc\":\"2020-10-08 20:40\",\"utc\":\"2020-10-08 12:40\"&#125;,\n\"status\":\"ok\",\n\"daily_forecast\":\n[&#123;\"cond_code_d\":\"305\",\"cond_code_n\":\"305\",\"cond_txt_d\":\"小雨\",\"cond_txt_n\":\"小雨\",\"date\":\"2020-10-08\",\"hum\":\"85\",\"mr\":\"22:51\",\"ms\":\"12:27\",\"pcpn\":\"1.4\",\"pop\":\"58\",\"pres\":\"967\",\"sr\":\"07:03\",\"ss\":\"18:39\",\"tmp_max\":\"19\",\"tmp_min\":\"16\",\"uv_index\":\"2\",\"vis\":\"25\",\"wind_deg\":\"59\",\"wind_dir\":\"东北风\",\"wind_sc\":\"1-2\",\"wind_spd\":\"3\"&#125;,\n&#123;\"cond_code_d\":\"305\",\"cond_code_n\":\"305\",\"cond_txt_d\":\"小雨\",\"cond_txt_n\":\"小雨\",\"date\":\"2020-10-09\",\"hum\":\"87\",\"mr\":\"23:43\",\"ms\":\"13:23\",\"pcpn\":\"1.0\",\"pop\":\"55\",\"pres\":\"963\",\"sr\":\"07:03\",\"ss\":\"18:38\",\"tmp_max\":\"20\",\"tmp_min\":\"16\",\"uv_index\":\"2\",\"vis\":\"25\",\"wind_deg\":\"0\",\"wind_dir\":\"北风\",\"wind_sc\":\"1-2\",\"wind_spd\":\"3\"&#125;,\n&#123;\"cond_code_d\":\"305\",\"cond_code_n\":\"305\",\"cond_txt_d\":\"小雨\",\"cond_txt_n\":\"小雨\",\"date\":\"2020-10-10\",\"hum\":\"88\",\"mr\":\"00:00\",\"ms\":\"14:15\",\"pcpn\":\"1.0\",\"pop\":\"55\",\"pres\":\"961\",\"sr\":\"07:04\",\"ss\":\"18:37\",\"tmp_max\":\"20\",\"tmp_min\":\"17\",\"uv_index\":\"2\",\"vis\":\"25\",\"wind_deg\":\"0\",\"wind_dir\":\"北风\",\"wind_sc\":\"1-2\",\"wind_spd\":\"3\"&#125;\n]&#125;]&#125;\n格式整理使用开发版的API只能提供三天的天气预报数据。从获取的信息中提取到天气描述、最高温度、最低温度、湿度、风向、风级、风速等信息。\nforecast = res['HeWeather6'][0]['daily_forecast']\nfor data in forecast:\n    cond_txt_d = data['cond_txt_d']  # weather 天气描述\n    tmp_max = data['tmp_max']  # max temperature.\n    tmp_min = data['tmp_min']  # min tempereture.\n    hum = data['hum']  # humanity\n    wind_dir = data['wind_dir']  # wind direction.\n    wind_sc = data['wind_sc']  # wind degree.\n    wind_spd = data['wind_spd']  # wind speed.\n\n发送邮件邮件发送模块采用菜鸟教程的demo即可完成。发送的邮箱可以选择国内的163邮箱，QQ邮箱。需要注意的是发送邮箱的token是需要到邮箱的设置页设置的，而不是常用的登录邮箱。这里建议将发件人姓名(username)发件人的邮箱地址，收件人的姓名、收件人的邮箱地址，全部放到配置文件中。这样做的目的是方便以后扩展和修改，避免修改程序；另一方面将其加入到gitingore文件中，就不会被同步。\n数据 -&gt; 格式 -&gt; 邮件发送通过将获取的天气预报数据整理格式，就可以发送天气预报到邮箱了。\n\n单纯的文字看上去就很“朴素”，为了增强用户的友好度，我们采用HTML美化。美化的方法是首先用html设计一个网页，然后再将需要显示的数据给替换为查询的天气信息。\n界面的美化是因人而异，直接copy了和风天气的UI。\n结论\n用最简单的方式爬取和风天气的API。仅用几行代码就可以获取到天气信息，这也是很多爬虫程序的第一步。\n邮件发送的模块是可以完全复用的。邮件发送的内容可以是普通的文本，html，图片，以及附件等。\n这里是实现了发送邮件的内容，下一步需要将其部署在树莓派中，且设置为定时任务。\n\n参考菜鸟教程：Python SMTP发送邮件https://github.com/Jarrettluo/Weather_Forecast\n","slug":"python实现自动发送天气预报到邮箱","date":"2020-10-30T14:09:53.000Z","categories_index":"","tags_index":"python","author_index":"JIARUI's BLOG"},{"id":"6b4aa81655f1909a16b68fb617987407","title":"使用NSIS打包Python安装程序","content":"1、前言程序设计好以后会生成若干可执行文件和依赖文件。为了方便程序被更好地使用，需要将程序封装为一个安装程序。\n2、平台和环境Windows系统安装NSIS下载地址：https://nsis.sourceforge.io/Download\nNSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序，提供了安装、卸载、系统设置、文件解压缩等功能。NSIS通过脚本语言来描述安装程序的行为和逻辑的。\n安装HW VNIS Edit下载地址：https://sourceforge.net/projects/hmne/\nHW VNISEDIT是他的这门语言的一个开发工具，能通过向导自动生成一些代码，下面我们做一个简单的应用程序打包步骤\n3、使用教程安装NSIS成功安装NSIS如下图所示。\n\nUser Manual\n进入HM VNISEdit窗口\nNSIS脚本向导选择文件-新建向导后进入向导窗口。\n\n填写应用程序信息应用程序的信息可以在安装程序右键后详细信息中查看。\n\n安装程序选项选择安装程序图标或者使用默认的图标。设置安装程序的文件、语言、用户图形界面。\n\n快闪屏幕和背景窗口基本不设置\n\n应用程序的目录与授权信息\n如果授权文件没有删除文本框中的文本。\n\n指定应用程序的文件\n选择文件树，如果安装程序要复制文件夹，则选择文件树时勾选包含子目录。\n\n应用程序图标和快捷方式\n可以在此过程中添加其他文件的快捷方式。其他文件如用户手册，设置程序等。\n安装后运行方式\n解决安装方式\n\n查看脚本\n修改脚本和输出脚本文件\n4、程序安装\n\n\n\n\n\n5、卸载程序\n\n\n6、安装程序个性化参考文档：https://www.cnblogs.com/modou/p/3573772.html\n7、生成安装程序出现的bug7.1 请指定安装程序语言？\n解决办法：\nHM VNISEdit 这个工具是第三方脚本编辑器。在编译的时候，它需要调用 NSIS 本身。之所以不出现语言选项，是因为它没检测到你的 NSIS 安装路径。在它菜单栏“NSIS”下找到“配置”，打开的界面中，有个“路径”选项，编译器路径浏览到 NSIS 文件夹下的 makensis.exe，帮助文件浏览到 NSIS 文件夹下的 help.chm 或NSIS.chm 即可正常加载语言。\n\n\n7.2 找不到License文件\n授权文件有的话就指定，没有就空着。\n7.3 安装目录没有文件夹[涉及机密] \n文件夹没有被打包进来：\n\n选择要打包的文件，直接把要打包的目录内容全部添加进来，注意两处*.*，以及勾选“包含子目录”，不要勾选”单独添加每个文件“，编译的时候会把所有的文件打包进来的，下一步\n8、其他参考资料：NSIS多语言支持：https://blog.csdn.net/zjlei712/article/details/39102337\n官方支持文档：https://nsis.sourceforge.io/FAQ\nNSIS使用教程：https://www.cnblogs.com/myall/p/3637759.html\n","slug":"使用NSIS打包Python安装程序","date":"2020-10-28T14:44:32.000Z","categories_index":"桌面程序","tags_index":"python","author_index":"JIARUI's BLOG"},{"id":"80e5c7b2462487b6594e56f63c56c243","title":"python制作软件许可证License文件生成器","content":"\n\n\n\n\n\n\n\n\n在写好软件以后，往往需要将软件打包发送给用户进行使用。但是若只希望给特定的用户进行使用，那么就需要将软件设置License（许可证）。本篇文章就来提供一种生成license文件的思路。\n\n1、前言 软件开发商完成一个软件的模块，希望交付给用户进行使用。软件开发商一般是希望只授权给某些用户使用，而不希望软件被其他未授权用户进行使用。因此需要开发一个软件授权的机制。当用户安装或者第一次使用软件的时候，软件是没有被授权的。当用户希望将软件绑定到某一台特定的计算机进行使用时，需要将目标计算机的MAC地址告知软件开发商，收到开发商的授权以后就能正常使用软件了。软件开发商收到授权请求时，获得软件安装的目标计算机的MAC地址。通过一套绑定mac地址的算法，生成了一个license，并且具有license失效的时间。生成的license同软件中内置的同一套算法生成的信息进行比对，如果比对上，那么授权成功。如果比对不上或者授权过期，那么授权失败。\n2、软件License的实现办法[暂无]\n3、使用PyQt5开发3.1 框架1、获取目标计算机的mac地址2、设置license过期的时间3、对mac和授权时间进行加密\n3.2 算法算法的核心就是，对mac地址进行hash计算。为了增加生成的license文件的困难度，在mac地址之前再加上一个特定的字符，让该license生成软件的破解难度可以稍微提高。例如在这里的示例代码中，特定字符暂定为first_key。\n\n\n\n\n\n\n\n\n\nHash算法的特点是，HASH的设计以无法解为目的；简单说来就是正向简单，逆向困难。\n#1、得到密钥，通过hash算法计算目标计算机的mac地址\n        psw = hash_msg('first_key' + str(self.mac_addr))\n#2、新建一个license_str 的字典，用于保存真实的mac地址，license失效时间，加密后的字符串\n        license_str = &#123;&#125;\n        license_str['mac'] = self.mac_addr\n        license_str['time_str'] = self.active_date\n        license_str['psw'] = psw\n\n生成的lincense_str作为一个字典，写入license文件中，是可以很直接地看出其组成。因此为了更进一步加密，保证写入license文件中地信息是无序且无意义地字符串，采用AEScoder进行加密\nfrom AEScoder import PrpCrypt\n\npc = PrpCrypt('keyskeyskeyskeys')  # 初始化密钥\ns_encrypt = pc.encrypt(str(license_str()))   # &lt;class 'bytes'>\nAES只有一个密钥，这个密钥既用来加密，也用于解密。例如在上面地示例代码中，采用了keyskeyskeyskeys作为密钥。该密钥在license生成软件中作为加密密钥，同时在使用license地软件中作为解密密钥。\nfrom AEScoder import PrpCrypt\npc = PrpCrypt('keyskeyskeyskeys')  # 初始化密钥\nd = pc.decrypt(s_encrypt)  # 解密\n将生成的license文件保存到特定的文件中，即完成了license的生成。\n# file_path即保存的文件路径\n# mac_str 是目标计算机的mac地址字符串\n# time_str 是授权目标计算机的使用时间，可以认为是license文件的失效时间\nfile_path = self.file_path + '/license_'+ mac_str + '_' + time_str + '.lic'\ns_encrypt = str(s_encrypt, encoding = \"utf-8\")   #  bytes to str\nwith open(file_path, 'w', encoding='utf-8') as lic:\n    lic.write(str(s_encrypt))\n    lic.close()\n3.3 代码实现利用Hash算法对一段字符进行运算python中实现对一段字符的运算时比较简单的，如下提供了一个示例代码。\nimport hashlib\n\ndef hash_msg(msg):\n    sha256 = hashlib.sha256()\n    sha256.update(msg.encode('utf-8'))\n    res = sha256.hexdigest()\n    return res\n\n获取本机的mac地址def get_mac_address():\n    mac = uuid.UUID(int = uuid.getnode()).hex[-12:]\n    return \":\".join([mac[e:e+2] for e in range(0,11,2)])\n\npyqt5实现界面class MainWindow(QMainWindow):\n    def __init__(self):\n        QMainWindow.__init__(self)\n        loadUi(\"Generator.ui\", self)\n        self.resize(405,480)\n        self.setMinimumSize(QtCore.QSize(415,490))\n        self.setMaximumSize(QtCore.QSize(415,490))\n        self.setWindowTitle('******软件激活码生成器')\n        self.setWindowIcon(QIcon('admin.ico'))\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    window = MainWindow()\n    window.show()\n    sys.exit(app.exec_())\n\n生成的license文件的字符串\n665dbda2a88fc8694d0df10e120236fd481087bd3e4d02c86f36ec\nba5d10eec24f5f0f5c8afb24cd8ee10c72df3c1d567a796c03a509\n5be96fdd1438e8121f0d780e6fc00784a1be9788661a7b18ed6e73\ne2ec337b251ede0f0be8f7287e63f0c69f202550dd45db55b62da9\nc886ba9da25165a6dd253ea9efe5a29e9637941c0d0a0b1cc1c6f0\n1225e6f61eaf520f24\n如果您感兴趣，可以通过以上算法生成激活码。\n4、程序打包使用PyInstaller将license文件生成软件进行打包一般常规的打包代码是：\npython -m PyInstaller -F license_generator.py\n如果想要给软件增加一个好看的图标，可以在打包的代码中加上打包图标的参数。\npython -m PyInstaller -F license_generator.py -i icon.ico\n\n在使用pyinstaller模块对pyqt5的程序进行打包的时候往往需要增加几行代码，用于指定其路径。\ndef app_path():\n    \"\"\"Returns the base application path.\"\"\"\n    if hasattr(sys, 'frozen'):\n        # Handles PyInstaller\n        return os.path.dirname(sys.executable) # 使用pyinstaller打包后的exe目录\n    return os.path.dirname(__file__) # 没打包前的py目录\n\nPROJECT_PATH = app_path()\n\n5、结尾1、该方法仅提供一种思路，即对mac地址和实效时间进行加密，生成字符。2、如果需要提供源代码进行调试，或者代为开发请联系。\n","slug":"python制作软件许可证License文件生成器","date":"2020-09-28T14:32:19.000Z","categories_index":"","tags_index":"python","author_index":"JIARUI's BLOG"},{"id":"d88dc7acfeea5f23c9e4f569a8841dba","title":"罗佳瑞的个人简历","content":"项目经历智能驾驶数据云平台 一期 ( 2020年12月 - 2021年10月 )\n\n\n\n\n\n\n\n\n项目简介: 2020年12月-10月，共计12个月。共10个人开发。产值 1200万。\n技术栈数据库：Mysql， Redis， 时序数据库消息中间件：kafka微服务：SpringCloud，Springboot\n工作职责PD\n项目成效\nL2等级的\n为多个汽车主机厂提供服务。\n\n智能驾驶车辆可视化 ( 2020年5月 - 2020年9月 )\n\n\n\n\n\n\n\n\n项目简介: 2020年5月 - 2020年9月，共计4个月。共5个人开发。\n技术栈\n数据采集层：Vicando，视频、激光雷达、毫米波雷达\n传输协议：WebSocket，rtmp\n视图层：Vue，Three.js\n\n工作职责项目负责人，数据架构设计，\n项目成效为多个汽车主机厂提供服务。\n车辆L2等级功能评估 （ 2020年7月 - 2020年12月 ）\n\n\n\n\n\n\n\n\n项目简介: 2020年7月 - 2020年12月，共计5个月。\n技术栈SpringCloud \n工作职责罗佳瑞\n项目成效为多个汽车主机厂提供服务。车载can总线协议解析。\n障碍物轨迹评估 （ 2020年4月 - 2020年6月 ）\n\n\n\n\n\n\n\n\n项目简介: 2020年4月 - 2020年6月。2个人开发。\n技术栈SpringCloud \n工作职责罗佳瑞\n项目成效为多个汽车主机厂提供服务。\n采集软件开发（ 2020年1月 - 2020年7月 ）\n\n\n\n\n\n\n\n\n项目简介: 2020年1月 - 2020年7月，共计7个月。\n技术栈SpringCloud \n工作职责罗佳瑞\n项目成效为多个汽车主机厂提供服务。\n\n工作成果项目成果\n\n智能驾驶数据存储分析平台V1.0\n\n\n车辆运行可视化软件（SLAM）\n\n\n轨迹对比软件\n\n\n智能驾驶功能评估软件\n\n\n二手车销售管家\n\n\n网络资源共享网站\n\n\n专利权转让网站\n\n\n二手车记账软件本地版\n\n\n多媒体计算程序\n\n论文\n\nJiarui Luo, Wenbo Luo, Kaisheng Zhang, etc., High specific detectivity infrared detector using crystal ion slicing transferred LiTaO3 single-crystal thin films,Sensors and Actuators A, 2019; 300:111650;(https://doi.org/10.1016/j.sna.2019.111650)\n\n\nWenbo Luo, Jiarui Luo, Yao Shuai etc., Infrared detector based on crystal ion sliced LiNbO3 single-crystal film with BCB bonding and thermal insulating layer, Microelectronic Eng., 2019; 213:1-5; (https://doi.org/10.1016/j.mee.2019.04.004)\n\n专利\n\n[中国发明] CN202110512220.2 一种雷达目标检测性能的测试方法及系统\n\n\n[中国实用新型] CN202020806176.7 交互式直流电源切换装置、不间断直流稳压电源及车辆\n\n\n[中国发明] CN201910187177.X 一种空腔型体声波谐振器及其制备方法\n\n\n工作经历\n2019年3月 - 2019年12月 北京经纬恒润科技有限公司 智能硬件工程师 \n\n\n2020年1月 - 至今 北京经纬恒润科技股份有限公司 智能驾驶数据平台开发工程师\n\n\n学习经历\n2016年9月 - 2019年6月 电子科技大学 电子科学与技术 硕士\n\n\n2012年9月 - 2016年6月 成都理工大学 新能源材料与器件专业\n\n\n2009年6月 - 2019年6月 四川省彭山一中 \n\n\n荣誉奖励\n2020年 北京经纬恒润科技股份有限公司 优秀新员工\n\n\n2019年 电子科技大学优秀毕业生\n\n\n2018年 电子科技大学优秀共产党员\n\n\n","slug":"罗佳瑞的个人简历","date":"2020-09-19T15:22:52.000Z","categories_index":"","tags_index":"简历","author_index":"JIARUI's BLOG"}]